{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","useState","timer","setTimer","console","log","isActive","setIsActive","isPaused","setIsPaused","countRef","useRef","current","getSeconds","slice","minutesRaw","minutes","Math","floor","getMinutes","getHours","handleStart","setInterval","className","class","classname","onClick","clearInterval","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oMA0JeA,EApJH,WAAM,MAGUC,mBAAS,GAHnB,mBAGTC,EAHS,KAGFC,EAHE,KAIhBC,QAAQC,IAAR,iCAAsCH,IAJtB,MAKgBD,oBAAS,GALzB,mBAKTK,EALS,KAKCC,EALD,OAMgBN,oBAAS,GANzB,mBAMTO,EANS,KAMCC,EAND,KAOVC,EAAWC,iBAAO,MAGxBP,QAAQC,IAAR,oBAAyBK,EAASE,UAQlC,IAAMC,EAAa,WAAKX,EAAQ,IAAMY,OAAO,GAGvCC,EAAab,EAAQ,GAErBc,EAAUC,KAAKC,MAAMH,GAErBI,EAAa,WAAIH,EAAU,IAAKF,OAAO,GAGvCM,EAAW,WAAIH,KAAKC,MAAMhB,EAAQ,OAAQY,OAAO,GAGvDV,QAAQC,IAAR,yBAA8BH,EAA9B,8BAAyDa,EAAzD,uBAAkFC,EAAlF,0BAA2GG,IAG3G,IAAME,EAAc,WAGlBd,GAAY,GACZE,GAAY,GAIZC,EAASE,QAAUU,aAAY,WAC7BnB,GAAS,SAACD,GAAD,OAAWA,EAAQ,OAC3B,MA4BL,OACE,sBAAKqB,UAAU,YAAf,UAIE,sBAAKC,MAAM,MAAX,UACE,qBAAKA,MAAM,QACX,sBAAKA,MAAM,gBAAX,UACE,yCAAW,uBAAX,qBACA,uDAAyB,uBAAzB,2BAEF,qBAAKA,MAAM,WAMZ,sBAAKD,UAAU,MAAf,UACC,qBAAKE,UAAU,UACf,sBAAKA,UAAU,cAAf,UACE,oBAAGF,UAAU,eAAb,UAA6BH,EAA7B,IAAwCD,EAAxC,IAAqDN,KADvD,OAGA,qBAAKY,UAAU,aAKjB,sBAAKD,MAAM,MAAX,UACE,qBAAKA,MAAM,QACX,sBAAKA,MAAM,iBAAX,UAqBOlB,GAAaE,EAKVA,EAAW,wBAAQkB,QA7Ef,WAClBC,cAAcjB,EAASE,SACvBR,QAAQC,IAAIK,EAASE,SACrBH,GAAY,IA0Ea,mBAIT,wBAAQiB,QAzEL,WACnBL,KAwEgB,oBARJ,wBAAQK,QAASL,EAAjB,mBAaJ,wBAAQK,QAzEE,WAClBC,cAAcjB,EAASE,SACvBL,GAAY,GACZE,GAAY,GACZN,EAAS,IAqED,sBAGJ,qBAAKqB,MAAM,eCrIJI,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCAdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.e6d9cddf.chunk.js","sourcesContent":["import React, { useState, useRef } from 'react';\nimport './App.css';\n\n//Esse app de cronômetro usará os hooks useState e o useRef do React.\n//O objetivo é viabilizar um cronômetro alterando os estados de forma dinâmica com o useState\n//e manter uma referência do status atual do countRef com useRef.\nconst App = () => {\n  //o hook useState retorna o valor inicial (timer), no nosso caso é zero, e também uma função \n  //pra atualizar este valor (setTimer).\n  const [timer, setTimer] = useState(0)\n  console.log(`Timer (total seconds): ${timer}`)\n  const [isActive, setIsActive] = useState(false)\n  const [isPaused, setIsPaused] = useState(false)\n  const countRef = useRef(null)\n  //o hook useRef é inicializado como null e seu valor só mudará quando o cronômetro for disparado.\n  //Ele retorna um objeto de ref mutável, ou seja, no andar do código ele vai sendo atualizado.\n  console.log(`countref: ${countRef.current}`)\n\n  //nosso cronômetro precisa mostrar segundos, minutos e horas. Para isso temos que usar o \n  //valor da const timer que, depois veremos, será atualizada a cada segundo.\n\n  //aqui fazemos a matemática para obter o retorno em segundos:\n  //mostro inicialmente 0 seguido do resto da divisão do valor do timer por 60. \n  //Deste número pego os dois últimos dígitos usando slice.\n  const getSeconds = `0${(timer % 60)}`.slice(-2)\n\n  //para os minutos primeiro crio um valor bruto que é o resultado de timer dividido por 60\n  const minutesRaw = timer / 60;\n  //depois arredondo para baixo esse valor.\n  const minutes = Math.floor(minutesRaw)\n  //e por fim pego também o resto da divisão dele por 60, fatiando os 2 últimos algarismos.\n  const getMinutes = `0${minutes % 60}`.slice(-2)\n\n  //para as horas é o valor dos 2 últimos algarismos de timer dividido por 3600(segundos) arredondado pra baixo.\n  const getHours = `0${Math.floor(timer / 3600)}`.slice(-2)\n\n  //para compreensão da lógica coloquei este console.log:\n  console.log(`Seconds (timer:${timer})/60 = Minute Raw: ${minutesRaw} - minutes: ${minutes} - getMinutes: ${getMinutes}`)\n  \n  //aqui o código que vai ser acinoado no botão de start. Ele basicamente:\n  const handleStart = () => {\n    //com useState define que as consts isActive e isPaused são true (pois o status inicial delas é false)\n    //essas consts é que definem se as funções de start, pause e resume estarão funcionais. \n    setIsActive(true)\n    setIsPaused(true)\n    //e manda um valor de ref para o countRef, que iniciamos como null, e a cada segundo (1000 milissegundos)\n    //atualiza a const timer com uma arrow function que leva como atributo o valor atual de timer e adiciona a ela \n    //mais 1. Para atualizar o timer usamos a função setTimer que é fornecida pelo hook useState.\n    countRef.current = setInterval(() => {\n      setTimer((timer) => timer + 1)\n    }, 1000)\n  }\n\n  //aqui tratamos do pause que basicamente define o isPaused como false e limpa o intervalo do nosso \n  //objeto de referencia que em última análise serve para definir quando nosso cronômetro está\n  //rodando (tem algum valor) ou quando está parado (null)\n  const handlePause = () => {\n    clearInterval(countRef.current)\n    console.log(countRef.current)\n    setIsPaused(false)\n  }\n\n  //o resume executa o start novamente. Como o intervalor de countRef não é alteardo o cronômetro \n  //continua de onde parou.\n  const handleResume = () => {\n    handleStart()\n  }\n\n  //O reset zera tudo.\n  const handleReset = () => {\n    clearInterval(countRef.current)\n    setIsActive(false)\n    setIsPaused(false)\n    setTimer(0)\n  }\n\n\n  \n  return (\n    <div className='container'>\n\n      {/* Linha do cabeçalho */}\n\n      <div class=\"row\">\n        <div class=\"col\"></div>\n        <div class=\"col-10 center\">\n          <h1>Tomi's <br />React Stopwatch</h1>\n          <h4>A complete stopwatch <br />running in ReactJS</h4>\n        </div>\n        <div class=\"col\"></div>\n      </div>\n\n\n      {/* Linha do relógio */}\n\n       <div className='row'>\n        <div classname='col-1'></div>\n        <div classname='col-10 stop'>\n          <p className=\"clock center\">{getHours}:{getMinutes}'{getSeconds}</p> {/* here we will show timer */}\n        </div>\n        <div classname='col-1'></div>\n      </div>\n\n      {/* Linha dos botões */}\n\n      <div class=\"row\">\n        <div class=\"col\"></div>\n        <div class=\"col-10 buttons\">\n          \n          {/* Aqui dá pra fazermos de duas formas, em relação aos botões:\n          O código abaixo vai gerar um botão para cada evento. \n          Resolvi deixar aqui só para propósito educativo pois a forma como faremos, com operadores ternários\n          nos permitirá que um botão tenha \"dois valores\", o que permite o uso de 2 botões somente. \n\n          <button onClick={handleStart}>Start</button>\n          <button onClick={handlePause}>Pause</button>\n          <button onClick={handleResume}>Resume</button>\n          <button onClick={handleReset}>Reset</button> */}\n\n\n            {/* Aqui vamos usar um operador ternário para fazer com que só apareçam dois botões\n          sendo que o start, ao iniciar vira pause, pause vira resume e ao lado o reset */}\n\n            {/* Operador ternário */}\n\n            {\n              //aqui funciona assim: se isActive e is paused forem false, ou seja, o estado inicial deles que definimos antes\n              //o botão será o de start.\n              !isActive && !isPaused ?\n                <button onClick={handleStart}>Start</button>\n                //se o is paused for true, ou seja, se o timer estiver rodando\n                //o botão que aparecerá será o de Pause.\n                : (\n                  isPaused ? <button onClick={handlePause}>Pause</button>\n                    //e depois de entrar nessa condição ele verifica se o isPaused continua true. Caso for false, \n                    //ou seja, se o timer tiver sido pausado, o botão que aparece é o de resume.\n                    :\n                    <button onClick={handleResume}>Resume</button>\n                )\n            }\n\n            {/* O botão de reset sempre vai aparecer pq está fora da nossa */}\n            <button onClick={handleReset}>Reset</button>\n          \n        </div>\n        <div class=\"col\"></div>\n      </div>\n\n\n    </div>\n  );\n}\n\n//exportamos tudo no App ;-)\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}